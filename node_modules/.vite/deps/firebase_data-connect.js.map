{
  "version": 3,
  "sources": ["../../@firebase/data-connect/src/core/version.ts", "../../@firebase/data-connect/src/core/AppCheckTokenProvider.ts", "../../@firebase/data-connect/src/core/error.ts", "../../@firebase/data-connect/src/logger.ts", "../../@firebase/data-connect/src/core/FirebaseAuthProvider.ts", "../../@firebase/data-connect/src/api/Reference.ts", "../../@firebase/data-connect/src/util/encoder.ts", "../../@firebase/data-connect/src/util/map.ts", "../../@firebase/data-connect/src/core/QueryManager.ts", "../../@firebase/data-connect/src/util/url.ts", "../../@firebase/data-connect/src/network/fetch.ts", "../../@firebase/data-connect/src/network/transport/rest.ts", "../../@firebase/data-connect/src/api/Mutation.ts", "../../@firebase/data-connect/src/api/DataConnect.ts", "../../@firebase/data-connect/src/register.ts", "../../@firebase/data-connect/src/api/query.ts", "../../@firebase/data-connect/src/util/validateArgs.ts", "../../@firebase/data-connect/src/api.browser.ts", "../../@firebase/data-connect/src/index.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/** The semver (www.semver.org) version of the SDK. */\nexport let SDK_VERSION = '';\n\n/**\n * SDK_VERSION should be set before any database instance is created\n * @internal\n */\nexport function setSDKVersion(version: string): void {\n  SDK_VERSION = version;\n}\n", "/**\n * @license\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  AppCheckInternalComponentName,\n  AppCheckTokenListener,\n  AppCheckTokenResult,\n  FirebaseAppCheckInternal\n} from '@firebase/app-check-interop-types';\nimport { Provider } from '@firebase/component';\n\n/**\n * @internal\n * Abstraction around AppCheck's token fetching capabilities.\n */\nexport class AppCheckTokenProvider {\n  private appCheck?: FirebaseAppCheckInternal;\n  constructor(\n    private appName_: string,\n    private appCheckProvider?: Provider<AppCheckInternalComponentName>\n  ) {\n    this.appCheck = appCheckProvider?.getImmediate({ optional: true });\n    if (!this.appCheck) {\n      void appCheckProvider\n        ?.get()\n        .then(appCheck => (this.appCheck = appCheck))\n        .catch();\n    }\n  }\n\n  getToken(forceRefresh?: boolean): Promise<AppCheckTokenResult> {\n    if (!this.appCheck) {\n      return new Promise<AppCheckTokenResult>((resolve, reject) => {\n        // Support delayed initialization of FirebaseAppCheck. This allows our\n        // customers to initialize the RTDB SDK before initializing Firebase\n        // AppCheck and ensures that all requests are authenticated if a token\n        // becomes available before the timoeout below expires.\n        setTimeout(() => {\n          if (this.appCheck) {\n            this.getToken(forceRefresh).then(resolve, reject);\n          } else {\n            resolve(null);\n          }\n        }, 0);\n      });\n    }\n    return this.appCheck.getToken(forceRefresh);\n  }\n\n  addTokenChangeListener(listener: AppCheckTokenListener): void {\n    void this.appCheckProvider\n      ?.get()\n      .then(appCheck => appCheck.addTokenListener(listener));\n  }\n}\n", "/**\n * @license\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { FirebaseError } from '@firebase/util';\n\nexport type DataConnectErrorCode =\n  | 'other'\n  | 'already-initialized'\n  | 'not-initialized'\n  | 'not-supported'\n  | 'invalid-argument'\n  | 'partial-error'\n  | 'unauthorized';\n\nexport type Code = DataConnectErrorCode;\n\nexport const Code = {\n  OTHER: 'other' as DataConnectErrorCode,\n  ALREADY_INITIALIZED: 'already-initialized' as DataConnectErrorCode,\n  NOT_INITIALIZED: 'not-initialized' as DataConnectErrorCode,\n  NOT_SUPPORTED: 'not-supported' as DataConnectErrorCode,\n  INVALID_ARGUMENT: 'invalid-argument' as DataConnectErrorCode,\n  PARTIAL_ERROR: 'partial-error' as DataConnectErrorCode,\n  UNAUTHORIZED: 'unauthorized' as DataConnectErrorCode\n};\n\n/** An error returned by a DataConnect operation. */\nexport class DataConnectError extends FirebaseError {\n  /** The stack of the error. */\n  readonly stack?: string;\n\n  /** @hideconstructor */\n  constructor(\n    /**\n     * The backend error code associated with this error.\n     */\n    readonly code: DataConnectErrorCode,\n    /**\n     * A custom error description.\n     */\n    readonly message: string\n  ) {\n    super(code, message);\n\n    // HACK: We write a toString property directly because Error is not a real\n    // class and so inheritance does not work correctly. We could alternatively\n    // do the same \"back-door inheritance\" trick that FirebaseError does.\n    this.toString = () => `${this.name}: [code=${this.code}]: ${this.message}`;\n  }\n}\n", "/**\n * @license\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { Logger, LogLevelString } from '@firebase/logger';\n\nimport { SDK_VERSION } from './core/version';\n\nconst logger = new Logger('@firebase/data-connect');\nexport function setLogLevel(logLevel: LogLevelString): void {\n  logger.setLogLevel(logLevel);\n}\nexport function logDebug(msg: string): void {\n  logger.debug(`DataConnect (${SDK_VERSION}): ${msg}`);\n}\n\nexport function logError(msg: string): void {\n  logger.error(`DataConnect (${SDK_VERSION}): ${msg}`);\n}\n", "/**\n * @license\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { FirebaseOptions } from '@firebase/app-types';\nimport {\n  FirebaseAuthInternal,\n  FirebaseAuthInternalName,\n  FirebaseAuthTokenData\n} from '@firebase/auth-interop-types';\nimport { Provider } from '@firebase/component';\n\nimport { logDebug, logError } from '../logger';\n\n// @internal\nexport interface AuthTokenProvider {\n  getToken(forceRefresh: boolean): Promise<FirebaseAuthTokenData | null>;\n  addTokenChangeListener(listener: AuthTokenListener): void;\n}\nexport type AuthTokenListener = (token: string | null) => void;\n\n// @internal\nexport class FirebaseAuthProvider implements AuthTokenProvider {\n  private _auth: FirebaseAuthInternal;\n  constructor(\n    private _appName: string,\n    private _options: FirebaseOptions,\n    private _authProvider: Provider<FirebaseAuthInternalName>\n  ) {\n    this._auth = _authProvider.getImmediate({ optional: true })!;\n    if (!this._auth) {\n      _authProvider.onInit(auth => (this._auth = auth));\n    }\n  }\n  getToken(forceRefresh: boolean): Promise<FirebaseAuthTokenData | null> {\n    if (!this._auth) {\n      return new Promise((resolve, reject) => {\n        setTimeout(() => {\n          if (this._auth) {\n            this.getToken(forceRefresh).then(resolve, reject);\n          } else {\n            resolve(null);\n          }\n        }, 0);\n      });\n    }\n    return this._auth.getToken(forceRefresh).catch(error => {\n      if (error && error.code === 'auth/token-not-initialized') {\n        logDebug(\n          'Got auth/token-not-initialized error.  Treating as null token.'\n        );\n        return null;\n      } else {\n        logError(\n          'Error received when attempting to retrieve token: ' +\n            JSON.stringify(error)\n        );\n        return Promise.reject(error);\n      }\n    });\n  }\n  addTokenChangeListener(listener: AuthTokenListener): void {\n    this._auth?.addAuthTokenListener(listener);\n  }\n  removeTokenChangeListener(listener: (token: string | null) => void): void {\n    this._authProvider\n      .get()\n      .then(auth => auth.removeAuthTokenListener(listener))\n      .catch(err => logError(err));\n  }\n}\n", "/**\n * @license\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { DataConnect, DataConnectOptions } from './DataConnect';\nexport const QUERY_STR = 'query';\nexport const MUTATION_STR = 'mutation';\nexport type ReferenceType = typeof QUERY_STR | typeof MUTATION_STR;\n\nexport const SOURCE_SERVER = 'SERVER';\nexport const SOURCE_CACHE = 'CACHE';\nexport type DataSource = typeof SOURCE_CACHE | typeof SOURCE_SERVER;\n\nexport interface OpResult<Data> {\n  data: Data;\n  source: DataSource;\n  fetchTime: string;\n}\n\nexport interface OperationRef<_Data, Variables> {\n  name: string;\n  variables: Variables;\n  refType: ReferenceType;\n  dataConnect: DataConnect;\n}\n\nexport interface DataConnectResult<Data, Variables> extends OpResult<Data> {\n  ref: OperationRef<Data, Variables>;\n  // future metadata\n}\n\n/**\n * Serialized RefInfo as a result of `QueryResult.toJSON().refInfo`\n */\nexport interface RefInfo<Variables> {\n  name: string;\n  variables: Variables;\n  connectorConfig: DataConnectOptions;\n}\n/**\n * Serialized Ref as a result of `QueryResult.toJSON()`\n */\nexport interface SerializedRef<Data, Variables> extends OpResult<Data> {\n  refInfo: RefInfo<Variables>;\n}\n", "/**\n * @license\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexport type HmacImpl = (obj: unknown) => string;\nexport let encoderImpl: HmacImpl;\nexport function setEncoder(encoder: HmacImpl): void {\n  encoderImpl = encoder;\n}\nsetEncoder(o => JSON.stringify(o));\n", "/**\n * @license\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexport function setIfNotExists<T>(\n  map: Map<string, T>,\n  key: string,\n  val: T\n): void {\n  if (!map.has(key)) {\n    map.set(key, val);\n  }\n}\n", "/**\n * @license\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  DataConnectSubscription,\n  OnErrorSubscription,\n  OnResultSubscription,\n  QueryPromise,\n  QueryRef,\n  QueryResult\n} from '../api/query';\nimport {\n  OperationRef,\n  QUERY_STR,\n  OpResult,\n  SerializedRef,\n  SOURCE_SERVER,\n  DataSource,\n  SOURCE_CACHE\n} from '../api/Reference';\nimport { logDebug } from '../logger';\nimport { DataConnectTransport } from '../network';\nimport { encoderImpl } from '../util/encoder';\nimport { setIfNotExists } from '../util/map';\n\nimport { Code, DataConnectError } from './error';\n\ninterface TrackedQuery<Data, Variables> {\n  ref: Omit<OperationRef<Data, Variables>, 'dataConnect'>;\n  subscriptions: Array<DataConnectSubscription<Data, Variables>>;\n  currentCache: OpResult<Data> | null;\n  lastError: DataConnectError | null;\n}\n\nfunction getRefSerializer<Data, Variables>(\n  queryRef: QueryRef<Data, Variables>,\n  data: Data,\n  source: DataSource\n) {\n  return function toJSON(): SerializedRef<Data, Variables> {\n    return {\n      data,\n      refInfo: {\n        name: queryRef.name,\n        variables: queryRef.variables,\n        connectorConfig: {\n          projectId: queryRef.dataConnect.app.options.projectId!,\n          ...queryRef.dataConnect.getSettings()\n        }\n      },\n      fetchTime: Date.now().toLocaleString(),\n      source\n    };\n  };\n}\n\nexport class QueryManager {\n  _queries: Map<string, TrackedQuery<unknown, unknown>>;\n  constructor(private transport: DataConnectTransport) {\n    this._queries = new Map();\n  }\n  track<Data, Variables>(\n    queryName: string,\n    variables: Variables,\n    initialCache?: OpResult<Data>\n  ): TrackedQuery<Data, Variables> {\n    const ref: TrackedQuery<Data, Variables>['ref'] = {\n      name: queryName,\n      variables,\n      refType: QUERY_STR\n    };\n    const key = encoderImpl(ref);\n    const newTrackedQuery: TrackedQuery<Data, Variables> = {\n      ref,\n      subscriptions: [],\n      currentCache: initialCache || null,\n      lastError: null\n    };\n    // @ts-ignore\n    setIfNotExists(this._queries, key, newTrackedQuery);\n    return this._queries.get(key) as TrackedQuery<Data, Variables>;\n  }\n  addSubscription<Data, Variables>(\n    queryRef: OperationRef<Data, Variables>,\n    onResultCallback: OnResultSubscription<Data, Variables>,\n    onErrorCallback?: OnErrorSubscription,\n    initialCache?: OpResult<Data>\n  ): () => void {\n    const key = encoderImpl({\n      name: queryRef.name,\n      variables: queryRef.variables,\n      refType: QUERY_STR\n    });\n    const trackedQuery = this._queries.get(key) as TrackedQuery<\n      Data,\n      Variables\n    >;\n    const subscription = {\n      userCallback: onResultCallback,\n      errCallback: onErrorCallback\n    };\n    const unsubscribe = (): void => {\n      const trackedQuery = this._queries.get(key)!;\n      trackedQuery.subscriptions = trackedQuery.subscriptions.filter(\n        sub => sub !== subscription\n      );\n    };\n    if (initialCache && trackedQuery.currentCache !== initialCache) {\n      logDebug('Initial cache found. Comparing dates.');\n      if (\n        !trackedQuery.currentCache ||\n        (trackedQuery.currentCache &&\n          compareDates(\n            trackedQuery.currentCache.fetchTime,\n            initialCache.fetchTime\n          ))\n      ) {\n        trackedQuery.currentCache = initialCache;\n      }\n    }\n    if (trackedQuery.currentCache !== null) {\n      const cachedData = trackedQuery.currentCache.data;\n      onResultCallback({\n        data: cachedData,\n        source: SOURCE_CACHE,\n        ref: queryRef as QueryRef<Data, Variables>,\n        toJSON: getRefSerializer(\n          queryRef as QueryRef<Data, Variables>,\n          trackedQuery.currentCache.data,\n          SOURCE_CACHE\n        ),\n        fetchTime: trackedQuery.currentCache.fetchTime\n      });\n      if (trackedQuery.lastError !== null && onErrorCallback) {\n        onErrorCallback(undefined);\n      }\n    }\n\n    trackedQuery.subscriptions.push({\n      userCallback: onResultCallback,\n      errCallback: onErrorCallback,\n      unsubscribe\n    });\n    if (!trackedQuery.currentCache) {\n      logDebug(\n        `No cache available for query ${\n          queryRef.name\n        } with variables ${JSON.stringify(\n          queryRef.variables\n        )}. Calling executeQuery.`\n      );\n      const promise = this.executeQuery(queryRef as QueryRef<Data, Variables>);\n      // We want to ignore the error and let subscriptions handle it\n      promise.then(undefined, err => {});\n    }\n    return unsubscribe;\n  }\n  executeQuery<Data, Variables>(\n    queryRef: QueryRef<Data, Variables>\n  ): QueryPromise<Data, Variables> {\n    if (queryRef.refType !== QUERY_STR) {\n      throw new DataConnectError(\n        Code.INVALID_ARGUMENT,\n        `ExecuteQuery can only execute query operation`\n      );\n    }\n    const key = encoderImpl({\n      name: queryRef.name,\n      variables: queryRef.variables,\n      refType: QUERY_STR\n    });\n    const trackedQuery = this._queries.get(key)!;\n    const result = this.transport.invokeQuery<Data, Variables>(\n      queryRef.name,\n      queryRef.variables\n    );\n    const newR = result.then(\n      res => {\n        const fetchTime = new Date().toString();\n        const result: QueryResult<Data, Variables> = {\n          ...res,\n          source: SOURCE_SERVER,\n          ref: queryRef,\n          toJSON: getRefSerializer(queryRef, res.data, SOURCE_SERVER),\n          fetchTime\n        };\n        trackedQuery.subscriptions.forEach(subscription => {\n          subscription.userCallback(result);\n        });\n        trackedQuery.currentCache = {\n          data: res.data,\n          source: SOURCE_CACHE,\n          fetchTime\n        };\n        return result;\n      },\n      err => {\n        trackedQuery.lastError = err;\n        trackedQuery.subscriptions.forEach(subscription => {\n          if (subscription.errCallback) {\n            subscription.errCallback(err);\n          }\n        });\n        throw err;\n      }\n    );\n\n    return newR;\n  }\n  enableEmulator(host: string, port: number): void {\n    this.transport.useEmulator(host, port);\n  }\n}\nfunction compareDates(str1: string, str2: string): boolean {\n  const date1 = new Date(str1);\n  const date2 = new Date(str2);\n  return date1.getTime() < date2.getTime();\n}\n", "/**\n * @license\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { DataConnectOptions, TransportOptions } from '../api/DataConnect';\nimport { Code, DataConnectError } from '../core/error';\nimport { logError } from '../logger';\n\nexport function urlBuilder(\n  projectConfig: DataConnectOptions,\n  transportOptions: TransportOptions\n): string {\n  const { connector, location, projectId: project, service } = projectConfig;\n  const { host, sslEnabled, port } = transportOptions;\n  const protocol = sslEnabled ? 'https' : 'http';\n  const realHost = host || `firebasedataconnect.googleapis.com`;\n  let baseUrl = `${protocol}://${realHost}`;\n  if (typeof port === 'number') {\n    baseUrl += `:${port}`;\n  } else if (typeof port !== 'undefined') {\n    logError('Port type is of an invalid type');\n    throw new DataConnectError(\n      Code.INVALID_ARGUMENT,\n      'Incorrect type for port passed in!'\n    );\n  }\n  return `${baseUrl}/v1beta/projects/${project}/locations/${location}/services/${service}/connectors/${connector}`;\n}\nexport function addToken(url: string, apiKey?: string): string {\n  if (!apiKey) {\n    return url;\n  }\n  const newUrl = new URL(url);\n  newUrl.searchParams.append('key', apiKey);\n  return newUrl.toString();\n}\n", "/**\n * @license\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Code, DataConnectError } from '../core/error';\nimport { SDK_VERSION } from '../core/version';\nimport { logDebug, logError } from '../logger';\n\nlet connectFetch: typeof fetch | null = globalThis.fetch;\nexport function initializeFetch(fetchImpl: typeof fetch): void {\n  connectFetch = fetchImpl;\n}\nfunction getGoogApiClientValue(_isUsingGen: boolean): string {\n  let str = 'gl-js/ fire/' + SDK_VERSION;\n  if (_isUsingGen) {\n    str += ' js/gen';\n  }\n  return str;\n}\nexport function dcFetch<T, U>(\n  url: string,\n  body: U,\n  { signal }: AbortController,\n  appId: string | null,\n  accessToken: string | null,\n  appCheckToken: string | null,\n  _isUsingGen: boolean\n): Promise<{ data: T; errors: Error[] }> {\n  if (!connectFetch) {\n    throw new DataConnectError(Code.OTHER, 'No Fetch Implementation detected!');\n  }\n  const headers: HeadersInit = {\n    'Content-Type': 'application/json',\n    'X-Goog-Api-Client': getGoogApiClientValue(_isUsingGen)\n  };\n  if (accessToken) {\n    headers['X-Firebase-Auth-Token'] = accessToken;\n  }\n  if (appId) {\n    headers['x-firebase-gmpid'] = appId;\n  }\n  if (appCheckToken) {\n    headers['X-Firebase-AppCheck'] = appCheckToken;\n  }\n  const bodyStr = JSON.stringify(body);\n  logDebug(`Making request out to ${url} with body: ${bodyStr}`);\n\n  return connectFetch(url, {\n    body: bodyStr,\n    method: 'POST',\n    headers,\n    signal\n  })\n    .catch(err => {\n      throw new DataConnectError(\n        Code.OTHER,\n        'Failed to fetch: ' + JSON.stringify(err)\n      );\n    })\n    .then(async response => {\n      let jsonResponse = null;\n      try {\n        jsonResponse = await response.json();\n      } catch (e) {\n        throw new DataConnectError(Code.OTHER, JSON.stringify(e));\n      }\n      const message = getMessage(jsonResponse);\n      if (response.status >= 400) {\n        logError(\n          'Error while performing request: ' + JSON.stringify(jsonResponse)\n        );\n        if (response.status === 401) {\n          throw new DataConnectError(Code.UNAUTHORIZED, message);\n        }\n        throw new DataConnectError(Code.OTHER, message);\n      }\n      return jsonResponse;\n    })\n    .then(res => {\n      if (res.errors && res.errors.length) {\n        const stringified = JSON.stringify(res.errors);\n        logError('DataConnect error while performing request: ' + stringified);\n        throw new DataConnectError(Code.OTHER, stringified);\n      }\n      return res as { data: T; errors: Error[] };\n    });\n}\ninterface MessageObject {\n  message?: string;\n}\nfunction getMessage(obj: MessageObject): string {\n  if ('message' in obj) {\n    return obj.message;\n  }\n  return JSON.stringify(obj);\n}\n", "/**\n * @license\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { DataConnectOptions, TransportOptions } from '../../api/DataConnect';\nimport { AppCheckTokenProvider } from '../../core/AppCheckTokenProvider';\nimport { DataConnectError, Code } from '../../core/error';\nimport { AuthTokenProvider } from '../../core/FirebaseAuthProvider';\nimport { logDebug } from '../../logger';\nimport { addToken, urlBuilder } from '../../util/url';\nimport { dcFetch } from '../fetch';\n\nimport { DataConnectTransport } from '.';\n\nexport class RESTTransport implements DataConnectTransport {\n  private _host = '';\n  private _port: number | undefined;\n  private _location = 'l';\n  private _connectorName = '';\n  private _secure = true;\n  private _project = 'p';\n  private _serviceName: string;\n  private _accessToken: string | null = null;\n  private _appCheckToken: string | null = null;\n  private _lastToken: string | null = null;\n  constructor(\n    options: DataConnectOptions,\n    private apiKey?: string | undefined,\n    private appId?: string,\n    private authProvider?: AuthTokenProvider | undefined,\n    private appCheckProvider?: AppCheckTokenProvider | undefined,\n    transportOptions?: TransportOptions | undefined,\n    private _isUsingGen = false\n  ) {\n    if (transportOptions) {\n      if (typeof transportOptions.port === 'number') {\n        this._port = transportOptions.port;\n      }\n      if (typeof transportOptions.sslEnabled !== 'undefined') {\n        this._secure = transportOptions.sslEnabled;\n      }\n      this._host = transportOptions.host;\n    }\n    const { location, projectId: project, connector, service } = options;\n    if (location) {\n      this._location = location;\n    }\n    if (project) {\n      this._project = project;\n    }\n    this._serviceName = service;\n    if (!connector) {\n      throw new DataConnectError(\n        Code.INVALID_ARGUMENT,\n        'Connector Name required!'\n      );\n    }\n    this._connectorName = connector;\n    this.authProvider?.addTokenChangeListener(token => {\n      logDebug(`New Token Available: ${token}`);\n      this._accessToken = token;\n    });\n    this.appCheckProvider?.addTokenChangeListener(result => {\n      const { token } = result;\n      logDebug(`New App Check Token Available: ${token}`);\n      this._appCheckToken = token;\n    });\n  }\n  get endpointUrl(): string {\n    return urlBuilder(\n      {\n        connector: this._connectorName,\n        location: this._location,\n        projectId: this._project,\n        service: this._serviceName\n      },\n      { host: this._host, sslEnabled: this._secure, port: this._port }\n    );\n  }\n  useEmulator(host: string, port?: number, isSecure?: boolean): void {\n    this._host = host;\n    if (typeof port === 'number') {\n      this._port = port;\n    }\n    if (typeof isSecure !== 'undefined') {\n      this._secure = isSecure;\n    }\n  }\n  onTokenChanged(newToken: string | null): void {\n    this._accessToken = newToken;\n  }\n\n  async getWithAuth(forceToken = false): Promise<string> {\n    let starterPromise: Promise<string | null> = new Promise(resolve =>\n      resolve(this._accessToken)\n    );\n    if (this.appCheckProvider) {\n      this._appCheckToken = (await this.appCheckProvider.getToken())?.token;\n    }\n    if (this.authProvider) {\n      starterPromise = this.authProvider\n        .getToken(/*forceToken=*/ forceToken)\n        .then(data => {\n          if (!data) {\n            return null;\n          }\n          this._accessToken = data.accessToken;\n          return this._accessToken;\n        });\n    } else {\n      starterPromise = new Promise(resolve => resolve(''));\n    }\n    return starterPromise;\n  }\n\n  _setLastToken(lastToken: string | null): void {\n    this._lastToken = lastToken;\n  }\n\n  withRetry<T>(\n    promiseFactory: () => Promise<{ data: T; errors: Error[] }>,\n    retry = false\n  ): Promise<{ data: T; errors: Error[] }> {\n    let isNewToken = false;\n    return this.getWithAuth(retry)\n      .then(res => {\n        isNewToken = this._lastToken !== res;\n        this._lastToken = res;\n        return res;\n      })\n      .then(promiseFactory)\n      .catch(err => {\n        // Only retry if the result is unauthorized and the last token isn't the same as the new one.\n        if (\n          'code' in err &&\n          err.code === Code.UNAUTHORIZED &&\n          !retry &&\n          isNewToken\n        ) {\n          logDebug('Retrying due to unauthorized');\n          return this.withRetry(promiseFactory, true);\n        }\n        throw err;\n      });\n  }\n\n  // TODO(mtewani): Update U to include shape of body defined in line 13.\n  invokeQuery: <T, U>(\n    queryName: string,\n    body?: U\n  ) => PromiseLike<{ data: T; errors: Error[] }> = <T, U = unknown>(\n    queryName: string,\n    body: U\n  ) => {\n    const abortController = new AbortController();\n    // TODO(mtewani): Update to proper value\n    const withAuth = this.withRetry(() =>\n      dcFetch<T, U>(\n        addToken(`${this.endpointUrl}:executeQuery`, this.apiKey),\n        {\n          name: `projects/${this._project}/locations/${this._location}/services/${this._serviceName}/connectors/${this._connectorName}`,\n          operationName: queryName,\n          variables: body\n        } as unknown as U, // TODO(mtewani): This is a patch, fix this.\n        abortController,\n        this.appId,\n        this._accessToken,\n        this._appCheckToken,\n        this._isUsingGen\n      )\n    );\n\n    return {\n      then: withAuth.then.bind(withAuth),\n      catch: withAuth.catch.bind(withAuth)\n    };\n  };\n  invokeMutation: <T, U>(\n    queryName: string,\n    body?: U\n  ) => PromiseLike<{ data: T; errors: Error[] }> = <T, U = unknown>(\n    mutationName: string,\n    body: U\n  ) => {\n    const abortController = new AbortController();\n    const taskResult = this.withRetry(() => {\n      return dcFetch<T, U>(\n        addToken(`${this.endpointUrl}:executeMutation`, this.apiKey),\n        {\n          name: `projects/${this._project}/locations/${this._location}/services/${this._serviceName}/connectors/${this._connectorName}`,\n          operationName: mutationName,\n          variables: body\n        } as unknown as U,\n        abortController,\n        this.appId,\n        this._accessToken,\n        this._appCheckToken,\n        this._isUsingGen\n      );\n    });\n\n    return {\n      then: taskResult.then.bind(taskResult),\n      // catch: taskResult.catch.bind(taskResult),\n      // finally: taskResult.finally.bind(taskResult),\n      cancel: () => abortController.abort()\n    };\n  };\n}\n", "/**\n * @license\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { DataConnectTransport } from '../network/transport';\n\nimport { DataConnect } from './DataConnect';\nimport {\n  DataConnectResult,\n  MUTATION_STR,\n  OperationRef,\n  SOURCE_SERVER\n} from './Reference';\n\nexport interface MutationRef<Data, Variables>\n  extends OperationRef<Data, Variables> {\n  refType: typeof MUTATION_STR;\n}\n\n/**\n * Creates a `MutationRef`\n * @param dcInstance Data Connect instance\n * @param mutationName name of mutation\n */\nexport function mutationRef<Data>(\n  dcInstance: DataConnect,\n  mutationName: string\n): MutationRef<Data, undefined>;\n/**\n *\n * @param dcInstance Data Connect instance\n * @param mutationName name of mutation\n * @param variables variables to send with mutation\n */\nexport function mutationRef<Data, Variables>(\n  dcInstance: DataConnect,\n  mutationName: string,\n  variables: Variables\n): MutationRef<Data, Variables>;\n/**\n *\n * @param dcInstance Data Connect instance\n * @param mutationName name of mutation\n * @param variables variables to send with mutation\n * @returns `MutationRef`\n */\nexport function mutationRef<Data, Variables>(\n  dcInstance: DataConnect,\n  mutationName: string,\n  variables?: Variables\n): MutationRef<Data, Variables> {\n  dcInstance.setInitialized();\n  const ref: MutationRef<Data, Variables> = {\n    dataConnect: dcInstance,\n    name: mutationName,\n    refType: MUTATION_STR,\n    variables: variables as Variables\n  };\n  return ref;\n}\n\n/**\n * @internal\n */\nexport class MutationManager {\n  private _inflight: Array<PromiseLike<unknown>> = [];\n  constructor(private _transport: DataConnectTransport) {}\n  executeMutation<Data, Variables>(\n    mutationRef: MutationRef<Data, Variables>\n  ): MutationPromise<Data, Variables> {\n    const result = this._transport.invokeMutation<Data, Variables>(\n      mutationRef.name,\n      mutationRef.variables\n    );\n    const withRefPromise = result.then(res => {\n      const obj: MutationResult<Data, Variables> = {\n        ...res, // Double check that the result is result.data, not just result\n        source: SOURCE_SERVER,\n        ref: mutationRef,\n        fetchTime: Date.now().toLocaleString()\n      };\n      return obj;\n    });\n    this._inflight.push(result);\n    const removePromise = (): Array<PromiseLike<unknown>> =>\n      (this._inflight = this._inflight.filter(promise => promise !== result));\n    result.then(removePromise, removePromise);\n    return withRefPromise;\n  }\n}\n\n/**\n * Mutation Result from `executeMutation`\n */\nexport interface MutationResult<Data, Variables>\n  extends DataConnectResult<Data, Variables> {\n  ref: MutationRef<Data, Variables>;\n}\n/**\n * Mutation return value from `executeMutation`\n */\nexport interface MutationPromise<Data, Variables>\n  extends PromiseLike<MutationResult<Data, Variables>> {\n  // reserved for special actions like cancellation\n}\n\n/**\n * Execute Mutation\n * @param mutationRef mutation to execute\n * @returns `MutationRef`\n */\nexport function executeMutation<Data, Variables>(\n  mutationRef: MutationRef<Data, Variables>\n): MutationPromise<Data, Variables> {\n  return mutationRef.dataConnect._mutationManager.executeMutation(mutationRef);\n}\n", "/**\n * @license\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  FirebaseApp,\n  _getProvider,\n  _removeServiceInstance,\n  getApp\n} from '@firebase/app';\nimport { AppCheckInternalComponentName } from '@firebase/app-check-interop-types';\nimport { FirebaseAuthInternalName } from '@firebase/auth-interop-types';\nimport { Provider } from '@firebase/component';\n\nimport { AppCheckTokenProvider } from '../core/AppCheckTokenProvider';\nimport { Code, DataConnectError } from '../core/error';\nimport {\n  AuthTokenProvider,\n  FirebaseAuthProvider\n} from '../core/FirebaseAuthProvider';\nimport { QueryManager } from '../core/QueryManager';\nimport { logDebug, logError } from '../logger';\nimport { DataConnectTransport, TransportClass } from '../network';\nimport { RESTTransport } from '../network/transport/rest';\n\nimport { MutationManager } from './Mutation';\n\n/**\n * Connector Config for calling Data Connect backend.\n */\nexport interface ConnectorConfig {\n  location: string;\n  connector: string;\n  service: string;\n}\n\n/**\n * Options to connect to emulator\n */\nexport interface TransportOptions {\n  host: string;\n  sslEnabled?: boolean;\n  port?: number;\n}\n\nconst FIREBASE_DATA_CONNECT_EMULATOR_HOST_VAR =\n  'FIREBASE_DATA_CONNECT_EMULATOR_HOST';\n\n/**\n *\n * @param fullHost\n * @returns TransportOptions\n * @internal\n */\nexport function parseOptions(fullHost: string): TransportOptions {\n  const [protocol, hostName] = fullHost.split('://');\n  const isSecure = protocol === 'https';\n  const [host, portAsString] = hostName.split(':');\n  const port = Number(portAsString);\n  return { host, port, sslEnabled: isSecure };\n}\n/**\n * DataConnectOptions including project id\n */\nexport interface DataConnectOptions extends ConnectorConfig {\n  projectId: string;\n}\n\n/**\n * Class representing Firebase Data Connect\n */\nexport class DataConnect {\n  _queryManager!: QueryManager;\n  _mutationManager!: MutationManager;\n  isEmulator = false;\n  _initialized = false;\n  private _transport!: DataConnectTransport;\n  private _transportClass: TransportClass | undefined;\n  private _transportOptions?: TransportOptions;\n  private _authTokenProvider?: AuthTokenProvider;\n  _isUsingGeneratedSdk: boolean = false;\n  private _appCheckTokenProvider?: AppCheckTokenProvider;\n  // @internal\n  constructor(\n    public readonly app: FirebaseApp,\n    // TODO(mtewani): Replace with _dataConnectOptions in the future\n    private readonly dataConnectOptions: DataConnectOptions,\n    private readonly _authProvider: Provider<FirebaseAuthInternalName>,\n    private readonly _appCheckProvider: Provider<AppCheckInternalComponentName>\n  ) {\n    if (typeof process !== 'undefined' && process.env) {\n      const host = process.env[FIREBASE_DATA_CONNECT_EMULATOR_HOST_VAR];\n      if (host) {\n        logDebug('Found custom host. Using emulator');\n        this.isEmulator = true;\n        this._transportOptions = parseOptions(host);\n      }\n    }\n  }\n  // @internal\n  _useGeneratedSdk(): void {\n    if (!this._isUsingGeneratedSdk) {\n      this._isUsingGeneratedSdk = true;\n    }\n  }\n  _delete(): Promise<void> {\n    _removeServiceInstance(\n      this.app,\n      'data-connect',\n      JSON.stringify(this.getSettings())\n    );\n    return Promise.resolve();\n  }\n\n  // @internal\n  getSettings(): ConnectorConfig {\n    const copy = JSON.parse(JSON.stringify(this.dataConnectOptions));\n    delete copy.projectId;\n    return copy;\n  }\n\n  // @internal\n  setInitialized(): void {\n    if (this._initialized) {\n      return;\n    }\n    if (this._transportClass === undefined) {\n      logDebug('transportClass not provided. Defaulting to RESTTransport.');\n      this._transportClass = RESTTransport;\n    }\n\n    if (this._authProvider) {\n      this._authTokenProvider = new FirebaseAuthProvider(\n        this.app.name,\n        this.app.options,\n        this._authProvider\n      );\n    }\n    if (this._appCheckProvider) {\n      this._appCheckTokenProvider = new AppCheckTokenProvider(\n        this.app.name,\n        this._appCheckProvider\n      );\n    }\n\n    this._initialized = true;\n    this._transport = new this._transportClass(\n      this.dataConnectOptions,\n      this.app.options.apiKey,\n      this.app.options.appId,\n      this._authTokenProvider,\n      this._appCheckTokenProvider,\n      undefined,\n      this._isUsingGeneratedSdk\n    );\n    if (this._transportOptions) {\n      this._transport.useEmulator(\n        this._transportOptions.host,\n        this._transportOptions.port,\n        this._transportOptions.sslEnabled\n      );\n    }\n    this._queryManager = new QueryManager(this._transport);\n    this._mutationManager = new MutationManager(this._transport);\n  }\n\n  // @internal\n  enableEmulator(transportOptions: TransportOptions): void {\n    if (\n      this._initialized &&\n      !areTransportOptionsEqual(this._transportOptions, transportOptions)\n    ) {\n      logError('enableEmulator called after initialization');\n      throw new DataConnectError(\n        Code.ALREADY_INITIALIZED,\n        'DataConnect instance already initialized!'\n      );\n    }\n    this._transportOptions = transportOptions;\n    this.isEmulator = true;\n  }\n}\n\n/**\n * @internal\n * @param transportOptions1\n * @param transportOptions2\n * @returns\n */\nexport function areTransportOptionsEqual(\n  transportOptions1: TransportOptions,\n  transportOptions2: TransportOptions\n): boolean {\n  return (\n    transportOptions1.host === transportOptions2.host &&\n    transportOptions1.port === transportOptions2.port &&\n    transportOptions1.sslEnabled === transportOptions2.sslEnabled\n  );\n}\n\n/**\n * Connect to the DataConnect Emulator\n * @param dc Data Connect instance\n * @param host host of emulator server\n * @param port port of emulator server\n * @param sslEnabled use https\n */\nexport function connectDataConnectEmulator(\n  dc: DataConnect,\n  host: string,\n  port?: number,\n  sslEnabled = false\n): void {\n  dc.enableEmulator({ host, port, sslEnabled });\n}\n\n/**\n * Initialize DataConnect instance\n * @param options ConnectorConfig\n */\nexport function getDataConnect(options: ConnectorConfig): DataConnect;\n/**\n * Initialize DataConnect instance\n * @param app FirebaseApp to initialize to.\n * @param options ConnectorConfig\n */\nexport function getDataConnect(\n  app: FirebaseApp,\n  options: ConnectorConfig\n): DataConnect;\nexport function getDataConnect(\n  appOrOptions: FirebaseApp | ConnectorConfig,\n  optionalOptions?: ConnectorConfig\n): DataConnect {\n  let app: FirebaseApp;\n  let dcOptions: ConnectorConfig;\n  if ('location' in appOrOptions) {\n    dcOptions = appOrOptions;\n    app = getApp();\n  } else {\n    dcOptions = optionalOptions!;\n    app = appOrOptions;\n  }\n\n  if (!app || Object.keys(app).length === 0) {\n    app = getApp();\n  }\n  const provider = _getProvider(app, 'data-connect');\n  const identifier = JSON.stringify(dcOptions);\n  if (provider.isInitialized(identifier)) {\n    const dcInstance = provider.getImmediate({ identifier });\n    const options = provider.getOptions(identifier);\n    const optionsValid = Object.keys(options).length > 0;\n    if (optionsValid) {\n      logDebug('Re-using cached instance');\n      return dcInstance;\n    }\n  }\n  validateDCOptions(dcOptions);\n\n  logDebug('Creating new DataConnect instance');\n  // Initialize with options.\n  return provider.initialize({\n    instanceIdentifier: identifier,\n    options: dcOptions\n  });\n}\n\n/**\n *\n * @param dcOptions\n * @returns {void}\n * @internal\n */\nexport function validateDCOptions(dcOptions: ConnectorConfig): boolean {\n  const fields = ['connector', 'location', 'service'];\n  if (!dcOptions) {\n    throw new DataConnectError(Code.INVALID_ARGUMENT, 'DC Option Required');\n  }\n  fields.forEach(field => {\n    if (dcOptions[field] === null || dcOptions[field] === undefined) {\n      throw new DataConnectError(Code.INVALID_ARGUMENT, `${field} Required`);\n    }\n  });\n  return true;\n}\n\n/**\n * Delete DataConnect instance\n * @param dataConnect DataConnect instance\n * @returns\n */\nexport function terminate(dataConnect: DataConnect): Promise<void> {\n  return dataConnect._delete();\n  // TODO(mtewani): Stop pending tasks\n}\n", "/**\n * @license\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n// eslint-disable-next-line import/no-extraneous-dependencies\nimport {\n  _registerComponent,\n  registerVersion,\n  SDK_VERSION\n} from '@firebase/app';\nimport { Component, ComponentType } from '@firebase/component';\n\nimport { name, version } from '../package.json';\nimport { setSDKVersion } from '../src/core/version';\n\nimport { DataConnect, ConnectorConfig } from './api/DataConnect';\nimport { Code, DataConnectError } from './core/error';\n\nexport function registerDataConnect(variant?: string): void {\n  setSDKVersion(SDK_VERSION);\n  _registerComponent(\n    new Component(\n      'data-connect',\n      (container, { instanceIdentifier: settings, options }) => {\n        const app = container.getProvider('app').getImmediate()!;\n        const authProvider = container.getProvider('auth-internal');\n        const appCheckProvider = container.getProvider('app-check-internal');\n        let newOpts = options as ConnectorConfig;\n        if (settings) {\n          newOpts = JSON.parse(settings);\n        }\n        if (!app.options.projectId) {\n          throw new DataConnectError(\n            Code.INVALID_ARGUMENT,\n            'Project ID must be provided. Did you pass in a proper projectId to initializeApp?'\n          );\n        }\n        return new DataConnect(\n          app,\n          { ...newOpts, projectId: app.options.projectId! },\n          authProvider,\n          appCheckProvider\n        );\n      },\n      ComponentType.PUBLIC\n    ).setMultipleInstances(true)\n  );\n  registerVersion(name, version, variant);\n  // BUILD_TARGET will be replaced by values like esm5, esm2017, cjs5, etc during the compilation\n  registerVersion(name, version, '__BUILD_TARGET__');\n}\n", "/**\n * @license\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { DataConnectError } from '../core/error';\n\nimport { DataConnect, getDataConnect } from './DataConnect';\nimport {\n  OperationRef,\n  QUERY_STR,\n  DataConnectResult,\n  SerializedRef\n} from './Reference';\n\n/**\n * Signature for `OnResultSubscription` for `subscribe`\n */\nexport type OnResultSubscription<Data, Variables> = (\n  res: QueryResult<Data, Variables>\n) => void;\n/**\n * Signature for `OnErrorSubscription` for `subscribe`\n */\nexport type OnErrorSubscription = (err?: DataConnectError) => void;\n/**\n * Signature for unsubscribe from `subscribe`\n */\nexport type QueryUnsubscribe = () => void;\n/**\n * Representation of user provided subscription options.\n */\nexport interface DataConnectSubscription<Data, Variables> {\n  userCallback: OnResultSubscription<Data, Variables>;\n  errCallback?: (e?: DataConnectError) => void;\n  unsubscribe: () => void;\n}\n\n/**\n * QueryRef object\n */\nexport interface QueryRef<Data, Variables>\n  extends OperationRef<Data, Variables> {\n  refType: typeof QUERY_STR;\n}\n/**\n * Result of `executeQuery`\n */\nexport interface QueryResult<Data, Variables>\n  extends DataConnectResult<Data, Variables> {\n  ref: QueryRef<Data, Variables>;\n  toJSON: () => SerializedRef<Data, Variables>;\n}\n/**\n * Promise returned from `executeQuery`\n */\nexport interface QueryPromise<Data, Variables>\n  extends PromiseLike<QueryResult<Data, Variables>> {\n  // reserved for special actions like cancellation\n}\n\n/**\n * Execute Query\n * @param queryRef query to execute.\n * @returns `QueryPromise`\n */\nexport function executeQuery<Data, Variables>(\n  queryRef: QueryRef<Data, Variables>\n): QueryPromise<Data, Variables> {\n  return queryRef.dataConnect._queryManager.executeQuery(queryRef);\n}\n\n/**\n * Execute Query\n * @param dcInstance Data Connect instance to use.\n * @param queryName Query to execute\n * @returns `QueryRef`\n */\nexport function queryRef<Data>(\n  dcInstance: DataConnect,\n  queryName: string\n): QueryRef<Data, undefined>;\n/**\n * Execute Query\n * @param dcInstance Data Connect instance to use.\n * @param queryName Query to execute\n * @param variables Variables to execute with\n * @returns `QueryRef`\n */\nexport function queryRef<Data, Variables>(\n  dcInstance: DataConnect,\n  queryName: string,\n  variables: Variables\n): QueryRef<Data, Variables>;\n/**\n * Execute Query\n * @param dcInstance Data Connect instance to use.\n * @param queryName Query to execute\n * @param variables Variables to execute with\n * @param initialCache initial cache to use for client hydration\n * @returns `QueryRef`\n */\nexport function queryRef<Data, Variables>(\n  dcInstance: DataConnect,\n  queryName: string,\n  variables?: Variables,\n  initialCache?: QueryResult<Data, Variables>\n): QueryRef<Data, Variables> {\n  dcInstance.setInitialized();\n  dcInstance._queryManager.track(queryName, variables, initialCache);\n  return {\n    dataConnect: dcInstance,\n    refType: QUERY_STR,\n    name: queryName,\n    variables: variables as Variables\n  };\n}\n/**\n * Converts serialized ref to query ref\n * @param serializedRef ref to convert to `QueryRef`\n * @returns `QueryRef`\n */\nexport function toQueryRef<Data, Variables>(\n  serializedRef: SerializedRef<Data, Variables>\n): QueryRef<Data, Variables> {\n  const {\n    refInfo: { name, variables, connectorConfig }\n  } = serializedRef;\n  return queryRef(getDataConnect(connectorConfig), name, variables);\n}\n/**\n * `OnCompleteSubscription`\n */\nexport type OnCompleteSubscription = () => void;\n/**\n * Representation of full observer options in `subscribe`\n */\nexport interface SubscriptionOptions<Data, Variables> {\n  onNext?: OnResultSubscription<Data, Variables>;\n  onErr?: OnErrorSubscription;\n  onComplete?: OnCompleteSubscription;\n}\n", "/**\n * @license\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  ConnectorConfig,\n  DataConnect,\n  getDataConnect\n} from '../api/DataConnect';\nimport { Code, DataConnectError } from '../core/error';\ninterface ParsedArgs<Variables> {\n  dc: DataConnect;\n  vars: Variables;\n}\n\n/**\n * The generated SDK will allow the user to pass in either the variable or the data connect instance with the variable,\n * and this function validates the variables and returns back the DataConnect instance and variables based on the arguments passed in.\n * @param connectorConfig\n * @param dcOrVars\n * @param vars\n * @param validateVars\n * @returns {DataConnect} and {Variables} instance\n * @internal\n */\nexport function validateArgs<Variables extends object>(\n  connectorConfig: ConnectorConfig,\n  dcOrVars?: DataConnect | Variables,\n  vars?: Variables,\n  validateVars?: boolean\n): ParsedArgs<Variables> {\n  let dcInstance: DataConnect;\n  let realVars: Variables;\n  if (dcOrVars && 'enableEmulator' in dcOrVars) {\n    dcInstance = dcOrVars as DataConnect;\n    realVars = vars;\n  } else {\n    dcInstance = getDataConnect(connectorConfig);\n    realVars = dcOrVars as Variables;\n  }\n  if (!dcInstance || (!realVars && validateVars)) {\n    throw new DataConnectError(Code.INVALID_ARGUMENT, 'Variables required.');\n  }\n  return { dc: dcInstance, vars: realVars };\n}\n", "/**\n * @license\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  OnCompleteSubscription,\n  OnErrorSubscription,\n  OnResultSubscription,\n  QueryRef,\n  QueryUnsubscribe,\n  SubscriptionOptions,\n  toQueryRef\n} from './api/query';\nimport { OpResult, SerializedRef } from './api/Reference';\nimport { DataConnectError, Code } from './core/error';\n\n/**\n * Subscribe to a `QueryRef`\n * @param queryRefOrSerializedResult query ref or serialized result.\n * @param observer observer object to use for subscribing.\n * @returns `SubscriptionOptions`\n */\nexport function subscribe<Data, Variables>(\n  queryRefOrSerializedResult:\n    | QueryRef<Data, Variables>\n    | SerializedRef<Data, Variables>,\n  observer: SubscriptionOptions<Data, Variables>\n): QueryUnsubscribe;\n/**\n * Subscribe to a `QueryRef`\n * @param queryRefOrSerializedResult query ref or serialized result.\n * @param onNext Callback to call when result comes back.\n * @param onError Callback to call when error gets thrown.\n * @param onComplete Called when subscription completes.\n * @returns `SubscriptionOptions`\n */\nexport function subscribe<Data, Variables>(\n  queryRefOrSerializedResult:\n    | QueryRef<Data, Variables>\n    | SerializedRef<Data, Variables>,\n  onNext: OnResultSubscription<Data, Variables>,\n  onError?: OnErrorSubscription,\n  onComplete?: OnCompleteSubscription\n): QueryUnsubscribe;\n/**\n * Subscribe to a `QueryRef`\n * @param queryRefOrSerializedResult query ref or serialized result.\n * @param observerOrOnNext observer object or next function.\n * @param onError Callback to call when error gets thrown.\n * @param onComplete Called when subscription completes.\n * @returns `SubscriptionOptions`\n */\nexport function subscribe<Data, Variables>(\n  queryRefOrSerializedResult:\n    | QueryRef<Data, Variables>\n    | SerializedRef<Data, Variables>,\n  observerOrOnNext:\n    | SubscriptionOptions<Data, Variables>\n    | OnResultSubscription<Data, Variables>,\n  onError?: OnErrorSubscription,\n  onComplete?: OnCompleteSubscription\n): QueryUnsubscribe {\n  let ref: QueryRef<Data, Variables>;\n  let initialCache: OpResult<Data> | undefined;\n  if ('refInfo' in queryRefOrSerializedResult) {\n    const serializedRef: SerializedRef<Data, Variables> =\n      queryRefOrSerializedResult;\n    const { data, source, fetchTime } = serializedRef;\n    initialCache = {\n      data,\n      source,\n      fetchTime\n    };\n    ref = toQueryRef(serializedRef);\n  } else {\n    ref = queryRefOrSerializedResult;\n  }\n  let onResult: OnResultSubscription<Data, Variables> | undefined = undefined;\n  if (typeof observerOrOnNext === 'function') {\n    onResult = observerOrOnNext;\n  } else {\n    onResult = observerOrOnNext.onNext;\n    onError = observerOrOnNext.onErr;\n    onComplete = observerOrOnNext.onComplete;\n  }\n  if (!onResult) {\n    throw new DataConnectError(Code.INVALID_ARGUMENT, 'Must provide onNext');\n  }\n  return ref.dataConnect._queryManager.addSubscription(\n    ref,\n    onResult,\n    onError,\n    initialCache\n  );\n}\n", "/**\n * Firebase Data Connect\n *\n * @packageDocumentation\n */\n\n/**\n * @license\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { DataConnect } from './api/DataConnect';\nimport { registerDataConnect } from './register';\n\nexport * from './api';\nexport * from './api.browser';\n\nregisterDataConnect();\n\ndeclare module '@firebase/component' {\n  interface NameServiceMapping {\n    'data-connect': DataConnect;\n  }\n}\n"],
  "mappings": "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",
  "names": ["SDK_VERSION", "version", "queryRef", "trackedQuery", "result", "mutationRef", "name"]
}
